#ifndef XCORE_LA_154_PROTOCOL_H
#define XCORE_LA_154_PROTOCOL_H

#include <array>

namespace xcore_la_154_protocol
{
	template <typename T, unsigned int N, typename TT, unsigned int NN>
	struct frame_pair{

		constexpr frame_pair(const std::array<T, N>& first, const std::array<TT, NN>& second) {
			tx = first;
			rx = second;
		}

		constexpr frame_pair(const T(&first)[N], const TT(&second)[NN]) {
			tx = array_factory(first);
			rx = array_factory(second);
		}

		template <typename T2, unsigned int N2>
		constexpr auto array_factory(const T2(&arr)[N2]) {
			auto a = std::array <unsigned char, N2>{};
			for (unsigned int i = 0; i < N2; i++) {
				a[i] = static_cast<unsigned char>(arr[i]);
			}
			return a;
		}

		std::array<unsigned char, N> tx;
		std::array<unsigned char, NN> rx;
	};

	template <typename T2, unsigned int N2>
	constexpr auto array_factory(const T2(&arr)[N2]) {
		auto a = std::array <unsigned char, N2>{};
		for (unsigned int i = 0; i < N2; i++) {
			a[i] = static_cast<unsigned char>(arr[i]);
		}
		return a;
	}

    unsigned char checksum(unsigned char* buffer, int size){
        unsigned char chk = 0;
        for(int i = 0; i < size; i++){
            chk += *(buffer + i);
        }
        return (chk % 256);
    }

	//serial number
	frame_pair SN_reader{{0xAA, 0x04, 0x00, 0x00, 0x00, 0xAE, 0xEB, 0xAA},
							{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};


	frame_pair br_reader{{0xAA, 0x04, 0x00, 0x3C, 0x00, 0xEA, 0xEB, 0xAA},
							{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};


	frame_pair ct_reader{{0xAA, 0x04, 0x00, 0x3B, 0x00, 0xE9, 0xEB, 0xAA},
							{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

	frame_pair br_setter{{0xAA, 0x06, 0x00, 0x3C, 0x01, 0x2C, 0x01, 0x1A, 0xEB, 0xAA},
							{0x55, 0x05, 0x00, 0x3C, 0x33, 0x01, 0xCA, 0xEB, 0xAA}};

	frame_pair br_incrementer{{0xAA, 0x06, 0x00, 0x41, 0x01, 0, 0, 0, 0xEB, 0xAA},
								{0x55, 0x05, 0x00, 0x41, 0x33, 0x01, 0xCF, 0xEB, 0xAA}};

	frame_pair ct_setter{{0xAA, 0x05, 0x00, 0x3B, 0x01, 0, 0, 0xEB, 0xAA},
							{0x55, 0x05, 0x00, 0x3B, 0x33, 0x01, 0xC9, 0xEB, 0xAA}};

	frame_pair ct_incrementer{{0xAA, 0x06, 0x00, 0x40, 0x01, 0x01, 0x00, 0x00, 0xEB, 0xAA},
								{0x55, 0x05, 0x00, 0x40, 0x33, 0x01, 0xCE, 0xEB, 0xAA}};

    frame_pair agc_manual_setter{{0xAA, 0x05, 0x00, 0x3A, 0x01, 0x00, 0xEA, 0xEB, 0xAA},
    								{0x55, 0x05, 0x00, 0x3A, 0x33, 0x01, 0xC8, 0xEB, 0xAA}};

    frame_pair agc_auto0_setter{{0xAA, 0x05, 0x00, 0x3A, 0x01, 0x01, 0xEB, 0xEB, 0xAA},
    								{0x55, 0x05, 0x00, 0x3A, 0x33, 0x01, 0xC8, 0xEB, 0xAA}};

    frame_pair agc_auto1_setter{{0xAA, 0x05, 0x00, 0x3A, 0x01, 0x02, 0xEC, 0xEB, 0xAA},
    								{0x55, 0x05, 0x00, 0x3A, 0x33, 0x01, 0xC8, 0xEB, 0xAA}};

    frame_pair agc_reader{{0xAA, 0x04, 0x00, 0x3A, 0x00, 0xE8, 0xEB, 0xAA},
    							{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

    frame_pair settings_saver{{0xAA, 0x04, 0x00, 0x11, 0x01, 0xC0, 0xEB, 0xAA},
    							{0x55, 0x05, 0x00, 0x11, 0x33, 0x01, 0x9F, 0xEB, 0xAA}};

    frame_pair image_flip_reader{{0xAA, 0x04, 0x00, 0x30, 0x00, 0xDE, 0xEB, 0xAA},
    								{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

    frame_pair image_flip_mirror_setter{{0xAA, 0x05, 0x00, 0x30, 0x01, 0x02, 0xE2, 0xEB, 0xAA},
    										{0x55, 0x05, 0x00, 0x30, 0x33, 0x01, 0xBE, 0xEB, 0xAA}};

    frame_pair image_flip_no_setter{{0xAA, 0x05, 0x00, 0x30, 0x01, 0x01, 0xE1, 0xEB, 0xAA},
    									{0x55, 0x05, 0x00, 0x30, 0x33, 0x01, 0xBE, 0xEB, 0xAA}};

    frame_pair image_palette_reader{{0xAA, 0x04, 0x00, 0x2D, 0x00, 0xDB, 0xEB, 0xAA},
    									{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

    frame_pair image_palette_black_hot_setter{{0xAA, 0x05, 0x00, 0x2D, 0x01, 0x01, 0xDE, 0xEB, 0xAA},
    											{0x55, 0x05, 0x00, 0x2D, 0x33, 0x01, 0xBB, 0xEB, 0xAA}};

    frame_pair image_palette_white_hot_setter{{0xAA, 0x05, 0x00, 0x2D, 0x01, 0x00, 0xDD, 0xEB, 0xAA},
    											{0x55, 0x05, 0x00, 0x2D, 0x33, 0x01, 0xBB, 0xEB, 0xAA}};

    auto update_br_setter(int set_value){
        unsigned char low = (set_value & 0xFF);
        unsigned char high = (set_value >> 8) & 0xFF;
        br_setter.tx[5] = low;
        br_setter.tx[6] = high;
        br_setter.tx[7] = checksum(br_setter.tx.data(), 7);
	}

    auto update_br_incrementer(int inc_val = 25){

    	br_incrementer.tx[5] = 0x01; 	//inc flag
        br_incrementer.tx[6] = inc_val;	//lower byte, ignore higher byte
        br_incrementer.tx[7] = checksum(br_incrementer.tx.data(), 7);
    }

    int extract_br(void){
        auto low = br_reader.rx.at(5);
        auto high = br_reader.rx.at(6);
        return (low | (high << 8));
    }

    auto update_ct_setter(int set_value){
    	ct_setter.tx[5] = set_value;
    	ct_setter.tx[6] = checksum(ct_setter.tx.data(), 6);
    }

    auto update_ct_incrementer(int inc_val = 10){
    	ct_incrementer.tx[5] = 0x01;
    	ct_incrementer.tx[6] = inc_val;
    	ct_incrementer.tx[7] = checksum(ct_incrementer.tx.data(), 7);
    }

    auto ct_extract(void){
        return ct_reader.rx[5];
    }

    auto agc_mode_is_in_manual(void){
        auto expected = array_factory({0x55, 0x05, 0x00, 0x3A, 0x33, 0x00, 0xC7, 0xEB, 0xAA});
        return expected == agc_reader.rx;
    }

    auto agc_mode_is_in_auto0(void){
        auto expected = array_factory({0x55, 0x05, 0x00, 0x3A, 0x33, 0x01, 0xC8, 0xEB, 0xAA});
        return (expected == agc_reader.rx);
    }

    auto agc_mode_is_in_auto1(void){
        auto expected = array_factory({0x55, 0x05, 0x00, 0x3A, 0x33, 0x02, 0xC9, 0xEB, 0xAA});
        return (expected == agc_reader.rx);
    }

    auto image_flip_is_in_mirror_frame(void){
        auto expected = array_factory({0x55, 0x05, 0x00, 0x30, 0x33, 0x02, 0xBF, 0xEB, 0xAA});
        return (image_flip_reader.rx == expected);
    }

    auto image_flip_is_in_no_frame(void){
    	auto expected = array_factory({0x55, 0x05, 0x00, 0x30, 0x33, 0x01, 0xBE, 0xEB, 0xAA});
    	return (image_flip_reader.rx == expected);
    }

    auto image_palette_is_in_white_hot(void){
    	return (image_palette_reader.rx[5] == 0x00);
    }

    auto image_palette_is_in_black_hot(void){
    	return (image_palette_reader.rx[5] == 0x01);
    }

};

#endif // XCORE_LA_154_PROTOCOL_H
